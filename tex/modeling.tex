In this section we show how to use the PRISM model checker~\cite{PRISM}
to derive the channels representing the behavior of the protocols
we analyze. 
%We start this section by presenting a general procedure to obtain channels that model protocols using PRISM.
%
%\begin{enumerate}
%\item Identify the sets $\calx$ and $\caly$, representing the secret and output values of the protocol in question,
%\item Implement the protocol on PRISM, taking care to have variables that can be set in a way to uniquely identify each element on the sets $\calx$ and $\caly$. A variable that signals the end of the protocol's execution might also be necessary.
%\item Set the variables accordingly for each value $x \in \calx$, and use PRISM to calculate the probability of each $y \in \caly$
%\end{enumerate} 

The general procedure to compute the channel corresponding to a protocol 
is the following.
(1) We identify the sets $\calx$ and $\caly$ representing, respectively, 
the secret and observable values of the protocol.
(2) We implement the protocol in PRISM, creating variables 
that can uniquely identify each element on the sets 
$\calx$ and $\caly$. 
A variable that signals the end of the protocol's execution is used.
(3) We set the variables accordingly for each value $x \in \calx$, 
and use PRISM to calculate the conditional probability $p(y \mid x)$ for 
each $y \in \caly$.

The third step can easily be accomplished by observing the first step, 
with the aid of an operator present in PRISM. 
Given a model, it is possible to verify the probability of taking a 
path from the initial state that respects a property \texttt{pathprop} 
with the operator
%\begin{verbatim}
%P =? [pathprop]
%\end{verbatim}
\texttt{P =? [pathprop]}.
If the second step is correctly observed, there is, for any $y \in \caly$, 
a way to make \texttt{pathprop} equivalent to the path formula 
$\mathcal{F} y$, where $\mathcal{F}$ is the finally operator. 
This path formula holds if and only if the system's output equals $y$. 
By setting the variables of the system to make the secret value $x \in \calx$ 
for all $x$, we can use this operator to systematically calculate $p(y|x)$ 
for every pair $x,y$, which defines our channel.

Next we illustrate how our general procedure can be applied to derive the 
channels corresponding to all variations of the protocols we consider.

\subsection{Modeling the Dining Cryptographers}
%\commentM{Arthur, \qm{modeling} is spelled with a single \qm{l}!}
%\replyA{C'mon, M{\' a}rio, British English is the best English! :) \\
%http://grammarist.com/spelling/model/} 
%\replyM{Well, I can't spell in British English, \\
%it's too \qm{colourful} for me!\\ }
We now discuss how to derive the channel for both variations of
the DC protocol: cycle-DC, and complete-DC. The first task is to
characterize $\calx$ and $\caly$, and to devise a suitable representation
of them to implement in our code.

Let $N$ denote the number of cryptographers in an instance of the
Dining Cryptographers protocol. 
In both variations of the protocol, the secret value is the identity 
of who pays the bill. 
%It can be either one of the cryptographers, represented by 
%$c_1,c_2,..c_N$, or the NSA, which we will represent by $n$. 
%Thus, we have $\calx=\{c_1,c_2,...,c_N,n\}$.
We have, then, $\calx=\{c_1,c_2,...,c_N,n\}$ where
each $c_{i}$ represents the case in which cryptographer $c_{i}$ is
the payer, and $n$ represents \review{in which} the case the NSA pays.

The observable values of the protocol, in both variations, are 
the public announcements made by all cryptographers. 
We can represent these announcements by \review{a} string of $N$ bits, 
where the value of the bit at position $i$ corresponds to the 
announcement of the cryptographer $c_i$. To ilustrate, consider
a protocol with four cryptographers. If $c_1$ and $c_2$ announced 1, 
and $c_3$ and $c_4$ announced 0, this would be represented by the 
string $1100$.
Hence, we can represent all possible outputs by taking $\caly=\review{\{0, 1\}}^{N}$.

Having established $\calx$ and $\caly$, as well as how to translate
their elements into variables in the code, we can write the protocol in PRISM
language. 
Our implementation is \review{available} online \cite{link}.
Table~\ref{table:channels} \review{depicts} the channels (omitting the NSA output)
computed by PRISM for cycle- and complete-DC, with the 
probability of heads equal to $0.7$.

%\paragraph{Implementing the protocol in PRISM.}
%We implement each cryptographer as a module of its own. 
%Below there is a simplified version of our code for one module 
%of the cycle variation.
%\commentM{We should consider making all this code available, and add the link here.}
%\replyA{No problem!}
%
%\begin{center}
%\begin{small}
%\begin{verbatim}
%module crypto_i \\module for the ith cryptographer
%    coin_i : [0..2] init 2; //Result: 0=tails, 1=heads,2=not tossed
%    announ_i : [0..1] init 0; //The cryptographer's announcement
%	
%    //A variable equal to 1 if crypto_i is paying
%    //"pay" is a user-defined variable indicating the value of the secret
%    paying_i: [0..1] init (pay=c_i)? 1:0;
%	
%    // Coin toss, with probcoin being the probability of it yielding heads
%    [] coin_i=2 -> probcoin: (coin_i'=1) + (1.0-probcoin) : (coin_i'=0);
%
%    //Making the announcement, considering the coin of another cryptographer
%    []coin_i<2&coin_(i+1)<2 -> (announ_i'=mod(coin_i+coin_(i+1)+paying_i,2));	
%endmodule
%\end{verbatim}
%\end{small}
%\end{center}

%Note that the user-defined variable \texttt{pay} (ranging in $\{0, \ldots, N\}$)
%uniquely defines the payer ($0$ being the case when it is the NSA), 
%while the variable \texttt{announ\_i} uniquely determines the 
%announcement of cryptographer $c_i$.
%The modules for complete-DC are analogous, but with more coins involved.
%
%\paragraph{Deriving the channel.}
%With our implementation, we can use the operator \texttt{P=?} to compute 
%each entry of our channel. 
%Table~\ref{table:channels} depict the channels 
%computed by PRISM for cycle- and complete-DC, with the 
%probability of heads equal to $0.7$.
\begin{table}[htb]
\centering
\begin{subtable}[b]{\linewidth}
\centering
$
\begin{array}{|c|c c c c c c c c|}
    \hline
    C_\textit{cycle-DC}   & \,\,\,\,1000\,\,\,\, & \,\,\,\,1100\,\,\,\, & \,\,\,\,0010\,\,\,\, & \,\,\,\,1110\,\,\,\, & \,\,\,\,0001\,\,\,\, & \,\,\,\,1101\,\,\,\, & \,\,\,\,1011\,\,\,\, & \,\,\,\,0111\,\,\,\,  \\
    \hline 
    c_{1} & 0.2482 & 0.1218 & 0.0882 & 0.1218 & 0.1218 & 0.0882 & 0.1218 & 0.0882 \\
    c_{2} & 0.1218 & 0.2482 & 0.1218 & 0.0882 & 0.0882 & 0.1218 & 0.0882 & 0.1218 \\
    c_{3} & 0.0882 & 0.1218 & 0.2482 & 0.1218 & 0.1218 & 0.0882 & 0.1218 & 0.0882 \\
    c_{4} & 0.1218 & 0.0882 & 0.1218 & 0.0882 & 0.2482 & 0.1218 & 0.0882 & 0.1218 \\ 
    \hline
\end{array}
$
\caption{Channel $C_\textit{cycle-DC}$ for the cycle-DC protocol.}
%\label{table:channel-cycle-dc}
\end{subtable}
\hfill
\begin{subtable}[b]{\linewidth}
\centering
$
\begin{array}{|c|c c c c c c c c|}
    \hline
    C_\textit{comp-DC} & \,\,\,\,1000\,\,\,\, & \,\,\,\,1100\,\,\,\, & \,\,\,\,0010\,\,\,\, & \,\,\,\,1110\,\,\,\, & \,\,\,\,0001\,\,\,\, & \,\,\,\,1101\,\,\,\, & \,\,\,\,1011\,\,\,\, & \,\,\,\,0111\,\,\,\, \\
    \hline 
    c_{1} & 0.1666 & 0.1218 & 0.1218 & 0.1218 & 0.1218 & 0.1218 & 0.1218 & 0.1026 \\ 
    c_{2} & 0.1218 & 0.1666 & 0.1218 & 0.1218 & 0.1218 & 0.1218 & 0.1026 & 0.1218 \\
    c_{3} & 0.1218 & 0.1218 & 0.1666 & 0.1218 & 0.1218 & 0.1026 & 0.1218 & 0.1218 \\
    c_{4} & 0.1218 & 0.1218 & 0.1218 & 0.1026 & 0.1666 & 0.1218 & 0.1218 & 0.1218 \\
    \hline
\end{array}
$
\caption{Channel $C_\textit{comp-DC}$ for the complete-DC protocol.}
%\label{table:channel-cycle-dc}
\end{subtable}
\caption{Channels for both variations of the \emph{Dining Cryptographers} protocol, 
with the probability of heads equal to $0.7$}
\label{table:channels}
\end{table}

\subsection{Modeling Crowds}

We now discuss how to derive the channel for both variations of
the Crowds protocol: original Crowds, and grid-Crowds. The first
step is to identify what the sets $\calx$ and $\caly$ shall 
represent, and to find \review{a suitable implementation} of them.

In both variations of the protocol, the secret value is the identity 
of the initiator of the request. 
There is no need to represent corrupt users, as we assume they 
do not initiate requests.
Therefore, we can represent the secret values set of Crowds with 
$N$ honest users by $\calx=\{u_1,u_2,...,u_N\}$.

The observable values are different in the two variations. 
In original Crowds, the server does not gain any information by 
identifying the user who forwarded the request to him, 
therefore we must have one output value $d_i$ representing 
the scenario in which each honest user $u_i$ was detected by a 
corrupt one, and another case $s$ representing the scenario where 
the server receives the request. 
Therefore, we have $\caly=\{d_1,...,d_N,s\}$.
%
In grid-Crowds, however, the identity of a user that forwards 
a request to the server is relevant.
We need, therefore, to break the output $s$ into multiple ones, 
indicating which user forwarded the request to the server. 
Thus, in this second variation, we must have 
$\caly=\{d_1,...,d_N,s_1,...,s_N\}$.

Having determined $\calx$ and $\caly$, it is possible to implement
the protocols in the PRISM language. Our implementation of all protocols
are available online \cite{link}\review{.}
%\paragraph{Implementing the protocol in PRISM.}
%For both variations, we implement each user (honest or corrupt) as its own module. 
%The following is a simplified version of our implementation of an user in the 
%original variation of the protocol.
%\commentM{Again, give link to implementation.}
%\begin{small}
%\begin{verbatim}
%//Global variables, that can be read and written by all modules
%global end: [0..1] init 0; //flag for end of the execution
%global sending:[0..N] init 0; //who last sent the request to another user
%global receiving: [0..N] init 0; //who will receive the request
%global detected:[0..N] init 0; //determines who is detected (0 for no one)
%//The module for user i
%module user_i
%   //decides whether the user initiates a request, according to whostarts
%  initiates_i: [0..1] init (c_i=whostarts)? 1:0; 
% 
%   forward_i: [0..1] init 0; //indicates whether user is forwarding 
%
%   //If user_i is the initiator, this command executes
%  //prouser is a constant, defined to be 1 over the number of users
% [] initiates_i -> prouser :(sending'=c_i)&(receiving'=1)&(initiator_i'=0) 
%+ ... + prouser : (sending'=c_i)&(receiving'=N)&(initiator_i'=0);
%
%    //Now, if user_i has received an request:
%    //If he is not honest, the user defined variable
%    //honest_i will be 0, and the user who sent will be detected
%    [] receiving=c_i&honest_i=0&end=0-> (detected'=sending)&(end'=1)&;v
%	
%    // If he is honest, he decides whether he will 
%    [] receiving=c_i&honest_i=0&forward_i=0&end=0 -> pf:(forward_i'=1)
%    +(1-pf):(sending'=c_i)&(end'=1); //send the request to the server
%    //If he forwards the request, he then decides to whom:    
%    [] forward_i=1 ->prouser : (sending'=c_i)&(receiving'=1)&(forward_i'=0)
%    + ... + prouser : (sending'=c_i)&(receinving'=N)&(forward_i'=0);
%endmodule
%\end{verbatim}
%\end{small}
%
%The implementation of grid-Crowds is analogous, the only 
%difference being the way by which users are connected to each other. 
%By controlling the value of \texttt{whostarts}, the user can uniquely 
%define the value of each $x \in \calx$, and by controlling the values 
%of \texttt{honest\_i}, he can also define the output set $\caly$.
%
%\paragraph{Computing the channel.}
%With our implementation, we can use the operator \texttt{P=?} to compute 
%each entry of our channel. 
%We performed experiments for 9 and 16 users in both variations with 
%differing numbers of corrupt users, making sure to explore all 
%possible topologies for the grid variation.